# 코플릿: 23 bubbleSort
<br/>

- **문제 설명**<br/>
정수를 요소로 갖는 배열을 입력받아 오름차순으로 정렬하여 리턴해야 합니다.
버블 정렬(bubble sort)은 여러 정렬 알고리즘(삽입 정렬, 퀵 정렬, 병합 정렬, 기수 정렬 등) 중 가장 기본적인 알고리즘입니다.

버블 정렬 알고리즘은 아래와 같습니다.

첫 번째 요소가 두 번째 요소보다 크면, 두 요소의 위치를 바꿉니다. (swap)
두 번째 요소와 세 번째 요소보다 크면, 두 요소의 위치를 바꿉니다. (swap)
1, 2를 마지막까지 반복합니다. (마지막에서 두 번째 요소와 마지막 요소를 비교)
1~3의 과정을 한 번 거치게 되면, 가장 큰 요소가 배열의 마지막으로 밀려납니다.
1~3의 과정을 첫 요소부터 다시 반복합니다.
5를 통해 두 번째로 큰 요소가 배열의 마지막 바로 두 번째로 밀려납니다.
1~3의 과정을 총 n번(배열의 크기) 반복합니다.
이 모습이 마치 '거품이 밀려 올라가는 것과 같은 모습'과 같아서 bubble sort라고 부릅니다.
- **제한사항**<br/>
위에서 설명한 알고리즘을 구현해야 합니다.
arr.sort 사용은 금지됩니다.
입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.

- **수도코드**<br/>
  1.이중포문을 돌린다.
  2.비교대상을 이동해주는 반복문 / 비교대상과 다른요소들을 비교해주는 반복문
  3.오름차순 정렬이 안되어 있을 경우에 만족하는 if문을 만들어서 걸러낸다.
  4.n번째 인덱스가 n+1번째 인덱스보다 크다면 자리를 바꿔준다.
  5.반복문이 종료되면 정렬이 완료된 배열을 리턴한다.
  6.오! 이런 시간 초과가뜬다.
  7.오름차순 정렬이 완료되면 반복을 멈춰 줄 조건을 걸어주자.

<br/>

```
function solution(n) {
 const bubbleSort = function (arr) {
  // TODO: 여기에 코드를 작성합니다.
  /*let sorrarr = arr.sort((a,b) => a-b)// 어쩐지 쉽더라 또 메서드 금지지?
  return sorrarr*/
    
  for(let i =0; i < arr.length;i++){ // 비교대상을 이동해주는 반복문
  let trade;
    for(let j = 0; j < arr.length-1;j++){ // 비교대상과 다른요소들을 비교해주는 반복문
      if(arr[j] > arr[j+1]){ // arr[j]가 5, arr[j+1]가 4라면
        trade = arr[j] // trade 는 5가되고
        arr[j] = arr[j+1] // arr[j]은 4가되고
        arr[j+1] = trade // arr[j+1]은 5가된다.
      }
    }
    // 이 조건에는 trade를 사용 할 일이 없는 경우를 조건으로 걸어야한다 / 모든 배열이 오름차순 정렬이 됐다면, 위에 if문에 들어가지 않는다.
    // 아무 조건이 들어가지 않은 trade를 콘솔로그 찍어보면 undefined
    // continue는 시간초과 뜬다
    // break
    if(trade===undefined){
          break
      } 
  }

  return arr
};
```

- **시행착오**<br/>
    - 배열내에서 값을 교환한다는 개념이 생소했다.
    - 오름차순으로 정렬한 새로운 배열을 리턴해야한다고 생각해서 push를 염두에 두고 있다가 고생 좀 했다.
    - 단순 할당으로 원본배열의 순서가 바뀔까? 의아했는데 정말 바뀌어서 놀랐다.
    - 마지막 브레이크를 걸어주기 전까지 재귀도 아닌데 시간초과가 떠서 당황했다.
  
