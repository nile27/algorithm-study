#소수를 찾는 알고리즘 입니다.

고대 그리스 수학자 에라토스테네스가 만들어넨 소수를 찾는 방법입니다.

~~이 방법은 마치 체로 치듯 수를 걸러낸다고 해서 ‘에라토스테네스의 체’라고 부릅니다.~~

원하는 정수의 그 이하의 소수를 찾는 가장 **간단하고 빠른 알고리즘 입니다.**

원리는

원하는 정수 이하의 배수(정수를 곱한수)를 

모두 지우면 소수만 남게 됩니다.

정확히는 원하는 정수의 루트(제곱근)를 구하고

그 숫자 이하 소수의 배수를 지우면

소수만 남게됩니다.

# 예시

---

120 이하의 소수.

1. 소수도, 합성수도 아닌 유일한 자연수 1은 제거합니다.
2. 2를 제외한 2의 배수를 제거합니다.
3. 3을 제외한 3의 배수를 제거합니다.
4. 5를 제외한 5의 배수를 제거합니다.(4의 배수는 2의 배수에서 이미 제거되었습니다.)
5. 7을 제외한 7의 배수를 제거합니다.

![Sieve_of_Eratosthenes_animation-6420e3488e509dce176a1e957ea07ff5.gif](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5cc046bc-b085-4a63-a811-862d57b0c4c0/Sieve_of_Eratosthenes_animation-6420e3488e509dce176a1e957ea07ff5.gif)

최종적으로 

2, 3, 5, 7, 

11, 13, 17, 19, 

23, 29, 

31, 37, 

41, 43, 47, 

53, 59, 

61, 67, 

71, 73, 79, 

83, 89, 97이 남습니다. 

---

한편, 에라토스테네스의 체를 이용해 1~n까지의 소수를 알고 싶다면, 

n까지 모든 수의 배수를 다 나눠 볼 필요 없습니다.

100의 루트, 

즉 10이하, 소수들의 배수만 이용한다면 모든 소수를 구할 수 있습니다.

예시로 11의 2의 배수 22는 2의 배수이기도 하기에 2의 배수에서 이미 제거되었습니다.

11의 3의 배수 33은 3의 배수이기도 하기에 3의 배수에서 이미 제거되었습니다.

마찬가지로 11의 제곱 121이전의 수는 모두 11이하의 소수들의 배수로 제거되었습니다.  

이러한 원리로 

정확히는 원하는 정수의 루트(제곱근)를 구하고

그 숫자 이하 소수의 배수를 지우면

소수만 남게됩니다.

가 성립됩니다.

#소수의 수를 구하는 함수


```
function solution(n) {
  const arr = [];
  

  // 0~n까지의 값을 true로 채운다.
	// true를 소수로 간주한다.
  // 배열은 0부터 시작하므로, 주어진 숫자 n에 1을 더해준다.
  for (let i = 0; i < n + 1; i++) {
      arr.push(true);
  }

	//n의 루트 이하 소수들의 배수만 이용한다면 모든 소수를 구할 수 있습니다.
	//(4 -> 9 -> 16 ...)
  for (let i = 2; i * i <= n; i += 1) {

    //i의 제곱에서 부터 판별을 하고 
    //이후로는 판별값의 i값을 더해준 값을 판별합니다.
    //4 -> 6 -> 8 ...
    for (let j = i * i; j <= n; j += i) {
        arr[j] = false;
    }

  }
  
  // 0과 1은 소수가 아니므로 false 값으로 바꿔준다.
  arr.splice(0, 2, false, false);
  
  // 배열에서 true인 값만 걸러내고, true인 값의 개수를 출력한다.
  const result = arr.filter((value) => {
      return value !== false;
  })
  

  return result.length;
}
```
