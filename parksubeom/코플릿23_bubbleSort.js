const bubbleSort = function (arr) {
  // TODO: 여기에 코드를 작성합니다.
/* 버블 정렬(bubble sort) 알고리즘의 구체적인 개념
   버블 정렬은 첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를, 세 번째와 네 번째를, … 이런 식으로 (마지막-1)번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬한다.
   1회전을 수행하고 나면 가장 큰 자료가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 자료는 정렬에서 제외되고,
   2회전을 수행하고 나면 끝에서 두 번째 자료까지는 정렬에서 제외된다. 이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.*/
  // arr[j] > arr[j+1] 이면 arr[j]가 arr[j+1]보다 앞으로 가야함 두개 값을 바꾼다? 둘이 스왑하는동안 값을 안고있을 제3의 인물이 필요하다. => trade
  // A,B,C 가 있다면,  A => B  /  C => A  /  B => C 
  // 시간이 초과했다고 뜬다. 정렬이 완료되면 멈출 조건을 찾자.

 // 1.이중포문을 돌린다.
 // 2.비교대상을 이동해주는 반복문 / 비교대상과 다른요소들을 비교해주는 반복문
 // 3.오름차순 정렬이 안되어 있을 경우에 만족하는 if문을 만들어서 걸러낸다.
 // 4.n번째 인덱스가 n+1번째 인덱스보다 크다면 자리를 바꿔준다.
 // 5.반복문이 종료되면 정렬이 완료된 배열을 리턴한다.
 // 6.오! 이런 시간 초과가뜬다.
  //7.오름차순 정렬이 완료되면 반복을 멈춰 줄 조건을 걸어주자.

  /*let sorrarr = arr.sort((a,b) => a-b)// 어쩐지 쉽더라 또 메서드 금지지?
  return sorrarr*/
    
  for(let i =0; i < arr.length;i++){ // 비교대상을 이동해주는 반복문
  let trade;
    for(let j = 0; j < arr.length-1;j++){ // 비교대상과 다른요소들을 비교해주는 반복문
      if(arr[j] > arr[j+1]){ // arr[j]가 5, arr[j+1]가 4라면
        trade = arr[j] // trade 는 5가되고
        arr[j] = arr[j+1] // arr[j]은 4가되고
        arr[j+1] = trade // arr[j+1]은 5가된다.
      }
    }
    // 이 조건에는 trade를 사용 할 일이 없는 경우를 조건으로 걸어야한다 / 모든 배열이 오름차순 정렬이 됐다면, 위에 if문에 들어가지 않는다.
    // 아무 조건이 들어가지 않은 trade를 콘솔로그 찍어보면 undefined
    // continue는 시간초과 뜬다
    // break
    if(trade===undefined){
          break
      } 
  }

  return arr
};
